<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kamen Rider Decade 3D Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            z-index: 100;
            display: block;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #score {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            color: white;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #health {
            position: absolute;
            top: 70px;
            width: 100%;
            text-align: center;
            color: white;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #form {
            position: absolute;
            top: 100px;
            width: 100%;
            text-align: center;
            color: white;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #transformInfo {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: white;
            z-index: 100;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 50px;
            text-align: center;
            display: none;
            z-index: 200;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #restart {
            display: block;
            margin: 20px auto;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        .controls {
            position: absolute;
            bottom: 50px;
            width: 100%;
            text-align: center;
            color: white;
            z-index: 100;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>

<body>
    <div id="info">KAMEN RIDER DECADE 3D GAME</div>
    <div id="score">Score: 0</div>
    <div id="health">Health: 100</div>
    <div id="form">Form: Decade Base Form</div>
    <div id="transformInfo">Press 1-5 to transform into different Rider forms!</div>
    <div class="controls">
        Controls: ←↑→↓ to move | SPACE to jump | SHIFT to dash | 1-5 to transform | Z to attack
    </div>
    <div id="gameOver">
        GAME OVER
        <button id="restart">Restart Game</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.159.0/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Game variables
        let scene, camera, renderer, rider, riderParts = {}, enemies = [], obstacles = [], effects = [];
        let clock = new THREE.Clock();
        let score = 0;
        let health = 100;
        let isGameOver = false;
        let moveSpeed = 0.15;
        let enemySpeed = 0.1;
        let roadLength = 1000;
        let laneWidth = 4;
        let lanes = [-laneWidth, 0, laneWidth];
        let currentLane = 1; // Middle lane
        let jumping = false;
        let jumpHeight = 3;
        let jumpSpeed = 0.15;
        let jumpPosition = 0;
        let spawnInterval;
        let isDashing = false;
        let dashSpeed = 0.4;
        let normalSpeed = 0.15;
        let currentForm = 'decade'; // Default form
        let isAttacking = false;
        let attackCooldown = 0;
        let moveDirection = { forward: false, backward: false, left: false, right: false };
        let riderZ = 0;

        // Rider forms with different properties and colors
        const riderForms = {
            decade: {
                name: 'Decade Base Form',
                colors: {
                    main: 0xFF00FF, // Magenta
                    secondary: 0x222222,
                    visor: 0x00FF00
                },
                attackPower: 1,
                speed: 1,
                dashMultiplier: 1
            },
            kuuga: {
                name: 'Kamen Rider Kuuga',
                colors: {
                    main: 0xDD0000, // Red
                    secondary: 0x111111,
                    visor: 0xFFFF00
                },
                attackPower: 1.5,
                speed: 1.2,
                dashMultiplier: 1.1
            },
            agito: {
                name: 'Kamen Rider Agito',
                colors: {
                    main: 0xFFD700, // Gold
                    secondary: 0x333333,
                    visor: 0xDD0000
                },
                attackPower: 1.3,
                speed: 1.3,
                dashMultiplier: 1.2
            },
            ryuki: {
                name: 'Kamen Rider Ryuki',
                colors: {
                    main: 0xFF0000, // Red
                    secondary: 0x444444,
                    visor: 0x111111
                },
                attackPower: 1.4,
                speed: 1.1,
                dashMultiplier: 1.3
            },
            faiz: {
                name: 'Kamen Rider Faiz',
                colors: {
                    main: 0x222222, // Black
                    secondary: 0xEEEEEE,
                    visor: 0xFF0000
                },
                attackPower: 1.6,
                speed: 1.4,
                dashMultiplier: 1.4
            }
        };

        // Initialize the game
        function init() {
            // Reset game state if restarting
            isGameOver = false;
            score = 0;
            health = 100;
            enemies = [];
            obstacles = [];
            effects = [];
            currentForm = 'decade';
            riderZ = 0;
            moveDirection = { forward: false, backward: false, left: false, right: false };

            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            scene.add(directionalLight);

            // Create road
            createRoad();

            // Create Kamen Rider character
            createRider();

            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // Update display
            updateScoreDisplay();
            updateHealthDisplay();
            updateFormDisplay();

            // Start spawning enemies and obstacles
            spawnInterval = setInterval(spawnEnemies, 2000);

            // Start animation loop
            animate();
        }

        function createRoad() {
            const roadGeometry = new THREE.PlaneGeometry(laneWidth * 5, roadLength);
            const roadMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.8
            });
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.z = -roadLength / 2;
            road.receiveShadow = true;
            scene.add(road);

            // Add road markings
            const lineGeometry = new THREE.PlaneGeometry(0.2, roadLength);
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });

            for (let x = -laneWidth; x <= laneWidth; x += laneWidth) {
                if (x !== -laneWidth && x !== laneWidth) {
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(x, 0.01, -roadLength / 2);
                    scene.add(line);
                }
            }

            // Add environment (simple grass fields)
            const grassGeometry = new THREE.PlaneGeometry(50, roadLength);
            const grassMaterial = new THREE.MeshStandardMaterial({ color: 0x7CFC00 });

            const leftGrass = new THREE.Mesh(grassGeometry, grassMaterial);
            leftGrass.rotation.x = -Math.PI / 2;
            leftGrass.position.set(-25, -0.01, -roadLength / 2);
            scene.add(leftGrass);

            const rightGrass = new THREE.Mesh(grassGeometry, grassMaterial);
            rightGrass.rotation.x = -Math.PI / 2;
            rightGrass.position.set(25, -0.01, -roadLength / 2);
            scene.add(rightGrass);

            // Add some decorative elements
            addEnvironmentObjects();
        }

        function addEnvironmentObjects() {
            // Add some trees
            for (let i = 0; i < 30; i++) {
                createTree(-20 - Math.random() * 15, -100 - i * 30);
                createTree(20 + Math.random() * 15, -100 - i * 30);
            }

            // Add some buildings in the background
            for (let i = 0; i < 10; i++) {
                createBuilding(-35 - Math.random() * 15, -100 - i * 80);
                createBuilding(35 + Math.random() * 15, -100 - i * 80);
            }
        }

        function createTree(x, z) {
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 4, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, 2, z);
            trunk.castShadow = true;
            scene.add(trunk);

            const foliageGeometry = new THREE.ConeGeometry(3, 6, 8);
            const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.set(x, 7, z);
            foliage.castShadow = true;
            scene.add(foliage);
        }

        function createBuilding(x, z) {
            const height = 10 + Math.random() * 20;
            const width = 5 + Math.random() * 10;
            const depth = 5 + Math.random() * 10;

            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            const buildingMaterial = new THREE.MeshStandardMaterial({
                color: 0x808080,
                roughness: 0.7
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.set(x, height / 2, z);
            building.castShadow = true;
            scene.add(building);

            // Add windows
            const windowSize = 1;
            const windowGeometry = new THREE.PlaneGeometry(windowSize, windowSize);
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFF99,
                emissive: 0xFFFF99,
                emissiveIntensity: 0.5
            });

            for (let i = 0; i < Math.floor(height / 3); i++) {
                for (let j = 0; j < Math.floor(width / 2); j++) {
                    const windowPane = new THREE.Mesh(windowGeometry, windowMaterial);
                    windowPane.position.set(
                        x - width / 2 + 1 + j * 2,
                        2 + i * 3,
                        z - depth / 2 - 0.1
                    );
                    scene.add(windowPane);
                }
            }
        }

        function createRider() {
            // Create a group for the rider
            rider = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.BoxGeometry(1, 1.5, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: riderForms[currentForm].colors.main });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.25;
            body.castShadow = true;
            rider.add(body);
            riderParts.body = body;

            // Head
            const headGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const headMaterial = new THREE.MeshStandardMaterial({ color: riderForms[currentForm].colors.main });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.5;
            head.castShadow = true;
            rider.add(head);
            riderParts.head = head;

            // Eye visor
            const visorGeometry = new THREE.BoxGeometry(0.8, 0.2, 0.6);
            const visorMaterial = new THREE.MeshStandardMaterial({
                color: riderForms[currentForm].colors.visor,
                emissive: riderForms[currentForm].colors.visor,
                emissiveIntensity: 0.5
            });
            const visor = new THREE.Mesh(visorGeometry, visorMaterial);
            visor.position.set(0, 2.5, 0.3);
            rider.add(visor);
            riderParts.visor = visor;

            // Legs
            const legGeometry = new THREE.BoxGeometry(0.4, 1, 0.4);
            const legMaterial = new THREE.MeshStandardMaterial({ color: riderForms[currentForm].colors.secondary });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.3, 0.5, 0);
            leftLeg.castShadow = true;
            rider.add(leftLeg);
            riderParts.leftLeg = leftLeg;

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.3, 0.5, 0);
            rightLeg.castShadow = true;
            rider.add(rightLeg);
            riderParts.rightLeg = rightLeg;

            // Arms
            const armGeometry = new THREE.BoxGeometry(0.3, 1, 0.3);
            const armMaterial = new THREE.MeshStandardMaterial({ color: riderForms[currentForm].colors.main });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.65, 1.25, 0);
            leftArm.castShadow = true;
            rider.add(leftArm);
            riderParts.leftArm = leftArm;

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.65, 1.25, 0);
            rightArm.castShadow = true;
            rider.add(rightArm);
            riderParts.rightArm = rightArm;

            // Add belt
            const beltGeometry = new THREE.BoxGeometry(1.1, 0.2, 0.6);
            const beltMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                metalness: 0.8,
                roughness: 0.2
            });
            const belt = new THREE.Mesh(beltGeometry, beltMaterial);
            belt.position.set(0, 0.7, 0);
            rider.add(belt);
            riderParts.belt = belt;

            // Add DecaDriver (Decade's belt buckle)
            const decaDriverGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.3);
            const decaDriverMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                metalness: 0.9,
                roughness: 0.1
            });
            const decaDriver = new THREE.Mesh(decaDriverGeometry, decaDriverMaterial);
            decaDriver.position.set(0, 0.7, 0.4);
            rider.add(decaDriver);
            riderParts.decaDriver = decaDriver;

            // Card slot in the DecaDriver
            const cardSlotGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.1);
            const cardSlotMaterial = new THREE.MeshStandardMaterial({
                color: riderForms[currentForm].colors.main,
                emissive: riderForms[currentForm].colors.main,
                emissiveIntensity: 0.3
            });
            const cardSlot = new THREE.Mesh(cardSlotGeometry, cardSlotMaterial);
            cardSlot.position.set(0, 0.7, 0.6);
            rider.add(cardSlot);
            riderParts.cardSlot = cardSlot;

            // Position the rider
            rider.position.set(lanes[currentLane], 0, riderZ);
            scene.add(rider);
        }

        function transformRider(formName) {
            if (!riderForms[formName]) return;

            // Create transformation effect
            createTransformEffect();

            // Change current form
            currentForm = formName;

            // Update display
            updateFormDisplay();

            // Update rider colors based on the new form
            riderParts.body.material.color.setHex(riderForms[currentForm].colors.main);
            riderParts.head.material.color.setHex(riderForms[currentForm].colors.main);
            riderParts.visor.material.color.setHex(riderForms[currentForm].colors.visor);
            riderParts.visor.material.emissive.setHex(riderForms[currentForm].colors.visor);
            riderParts.leftLeg.material.color.setHex(riderForms[currentForm].colors.secondary);
            riderParts.rightLeg.material.color.setHex(riderForms[currentForm].colors.secondary);
            riderParts.leftArm.material.color.setHex(riderForms[currentForm].colors.main);
            riderParts.rightArm.material.color.setHex(riderForms[currentForm].colors.main);
            riderParts.cardSlot.material.color.setHex(riderForms[currentForm].colors.main);
            riderParts.cardSlot.material.emissive.setHex(riderForms[currentForm].colors.main);

            // Update movement speed based on the form
            normalSpeed = 0.15 * riderForms[currentForm].speed;
            dashSpeed = normalSpeed * riderForms[currentForm].dashMultiplier;
        }

        function createTransformEffect() {
            // Create a sphere that expands from the rider
            const effectGeometry = new THREE.SphereGeometry(0.1, 32, 32);
            const effectMaterial = new THREE.MeshBasicMaterial({
                color: riderForms[currentForm].colors.main,
                transparent: true,
                opacity: 0.7
            });
            const effect = new THREE.Mesh(effectGeometry, effectMaterial);
            effect.position.copy(rider.position);
            effect.scale.set(1, 1, 1);
            effect.userData.type = "effect";
            effect.userData.lifespan = 30; // frames
            scene.add(effect);
            effects.push(effect);

            // Add some particles
            for (let i = 0; i < 20; i++) {
                const particleGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: riderForms[currentForm].colors.visor,
                    transparent: true,
                    opacity: 0.9
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);

                // Random position around the rider
                particle.position.set(
                    rider.position.x + (Math.random() - 0.5) * 3,
                    rider.position.y + Math.random() * 4,
                    rider.position.z + (Math.random() - 0.5) * 3
                );

                // Random velocity
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * 0.2,
                    (Math.random() - 0.5) * 0.2
                );

                particle.userData.type = "particle";
                particle.userData.lifespan = 30 + Math.random() * 30; // frames
                scene.add(particle);
                effects.push(particle);
            }
        }

        function createAttackEffect() {
            // Create a slash effect
            const slashGeometry = new THREE.PlaneGeometry(4, 1);
            const slashMaterial = new THREE.MeshBasicMaterial({
                color: riderForms[currentForm].colors.visor,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            const slash = new THREE.Mesh(slashGeometry, slashMaterial);

            // Position the slash in front of the rider
            slash.position.set(
                rider.position.x,
                rider.position.y + 1,
                rider.position.z - 2
            );

            slash.rotation.y = Math.PI / 2;
            slash.userData.type = "slash";
            slash.userData.lifespan = 10; // frames
            slash.userData.damage = 30 * riderForms[currentForm].attackPower;
            scene.add(slash);
            effects.push(slash);
        }

        function createEnemy() {
            const rnd = Math.random();
            const laneIndex = Math.floor(Math.random() * lanes.length);
            const lane = lanes[laneIndex];
            const zPosition = -100 - Math.random() * 50; // Randomize starting distance

            let enemy;

            if (rnd < 0.7) { // 70% chance for normal enemy
                // Create enemy monster
                const group = new THREE.Group();

                const bodyGeometry = new THREE.BoxGeometry(1.2, 1.8, 0.6);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.4;
                body.castShadow = true;
                group.add(body);

                const headGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const headMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2.7;
                head.castShadow = true;
                group.add(head);

                // Eyes
                const eyeGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFF0000,
                    emissive: 0xFF0000,
                    emissiveIntensity: 0.5
                });

                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.2, 2.7, 0.4);
                group.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.2, 2.7, 0.4);
                group.add(rightEye);

                enemy = group;
                enemy.userData.type = "enemy";
                enemy.userData.value = 100;
                enemy.userData.health = 100;
            } else { // 30% chance for obstacle
                const obstacleGeometry = new THREE.BoxGeometry(1.5, 1, 1.5);
                const obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                enemy = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                enemy.position.y = 0.5;
                enemy.castShadow = true;
                enemy.userData.type = "obstacle";
                enemy.userData.value = 0;
                enemy.userData.health = 50;
            }

            enemy.position.set(lane, 0, zPosition);
            scene.add(enemy);
            enemies.push(enemy);
        }

        function spawnEnemies() {
            if (!isGameOver) {
                createEnemy();
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            if (isGameOver) return;

            switch (event.code) {
                case 'ArrowLeft':
                    moveDirection.left = true;
                    break;
                case 'ArrowRight':
                    moveDirection.right = true;
                    break;
                case 'ArrowUp':
                    moveDirection.forward = true;
                    break;
                case 'ArrowDown':
                    moveDirection.backward = true;
                    break;
                case 'Space':
                    if (!jumping) {
                        jumping = true;
                        jumpPosition = 0;
                    }
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isDashing = true;
                    break;
                case 'KeyZ':
                    if (attackCooldown <= 0) {
                        isAttacking = true;
                        createAttackEffect();
                        attackCooldown = 30; // 30 frames cooldown
                    }
                    break;
                case 'Digit1':
                    transformRider('decade');
                    break;
                case 'Digit2':
                    transformRider('kuuga');
                    break;
                case 'Digit3':
                    transformRider('agito');
                    break;
                case 'Digit4':
                    transformRider('ryuki');
                    break;
                case 'Digit5':
                    transformRider('faiz');
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowLeft':
                    moveDirection.left = false;
                    break;
                case 'ArrowRight':
                    moveDirection.right = false;
                    break;
                case 'ArrowUp':
                    moveDirection.forward = false;
                    break;
                case 'ArrowDown':
                    moveDirection.backward = false;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isDashing = false;
                    break;
                case 'KeyZ':
                    isAttacking = false;
                    break;
            }
        }

        function handleMovement(delta) {
            // Set the current speed based on whether dashing is active
            const currentSpeed = isDashing ? dashSpeed : normalSpeed;

            // Handle lane changes (left/right)
            if (moveDirection.left && !jumping) {
                if (currentLane > 0) {
                    currentLane--;
                    const targetX = lanes[currentLane];
                    rider.position.x = targetX;
                }
                moveDirection.left = false; // Reset to prevent continuous movement
            }

            if (moveDirection.right && !jumping) {
                if (currentLane < lanes.length - 1) {
                    currentLane++;
                    const targetX = lanes[currentLane];
                    rider.position.x = targetX;
                }
                moveDirection.right = false; // Reset to prevent continuous movement
            }

            // Handle forward/backward movement
            if (moveDirection.forward) {
                riderZ -= currentSpeed;
                rider.position.z = riderZ;
            }

            if (moveDirection.backward) {
                riderZ += currentSpeed * 0.5; // Slower backward movement
                rider.position.z = riderZ;
            }

            // Handle jumping
            if (jumping) {
                // Simple parabolic jump
                jumpPosition += jumpSpeed;

                if (jumpPosition <= Math.PI) {
                    rider.position.y = Math.sin(jumpPosition) * jumpHeight;
                } else {
                    rider.position.y = 0;
                    jumping = false;
                    jumpPosition = 0;
                }
            }

            // Update camera to follow the rider
            camera.position.z = rider.position.z + 10;
            camera.lookAt(rider.position.x, rider.position.y + 1, rider.position.z - 5);

            // Animate the rider during movement
            animateRider(delta);
        }

        function animateRider(delta) {
            // Simple animation for the rider during movement or attacks
            if (moveDirection.forward || moveDirection.backward || isDashing) {
                // Swing legs while moving
                riderParts.leftLeg.rotation.x = Math.sin(Date.now() * 0.01) * 0.5;
                riderParts.rightLeg.rotation.x = Math.sin(Date.now() * 0.01 + Math.PI) * 0.5;

                // Swing arms while moving
                riderParts.leftArm.rotation.x = Math.sin(Date.now() * 0.01 + Math.PI) * 0.3;
                riderParts.rightArm.rotation.x = Math.sin(Date.now() * 0.01) * 0.3;
            } else {
                // Reset animations when not moving
                riderParts.leftLeg.rotation.x = 0;
                riderParts.rightLeg.rotation.x = 0;
                riderParts.leftArm.rotation.x = 0;
                riderParts.rightArm.rotation.x = 0;
            }

            // Animation for attacking
            if (isAttacking) {
                riderParts.rightArm.rotation.x = -Math.PI / 2; // Extend arm forward
            }

            // If transforming or special effects, could add more animations here
        }